---
title: "[OS 공룡책] Chapter 1. 서론"
excerpt_separator: <!--more-->
categories:
  - "Operating System"
use_math: true
---

> 본 포스트는 **공룡책**이라 불리는 **Abraham Silberschatz, Peter B. Galvin, Greg Gagne**의 **Operating System Concept 10th** 을 바탕으로 작성하였습니다.

**운영체제(operating system)** 는 **응용 프로그램을 위한 기반을 제공**하고 **컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행**하는 컴퓨터 하드웨어를 관리하는 소프트웨어이다.

## 1.1 운영체제가 할 일 (What Operating Systems Do)

컴퓨터 시스템의 구성 요소

![image](https://user-images.githubusercontent.com/59808674/163137606-d7181628-cdeb-4e7e-8531-8779223c0bd5.png)

- 하드웨어(hardware)
  - 중앙처리장치(CPU), 메모리, 입출력(I/O)장치
- 운영체제(operating system)
- 응용 프로그램(application program)
  - 워드프로세서, 스프레드시트, 컴파일러, 웹 브라우저
- 사용자(user)

### 1.1.3 운영체제의 정의

운영체제의 보편적인 정의는 없지만, 일반적인 정의로써는 컴퓨터에서 항상 실행되는 프로그램, 커널(kernel)이라고 한다.

커널과 함께 두 가지의 다른 프로그램이 있다:

- 시스템 프로그램(system program)
  - 운영체제와 관련은 있지만 반드시 커널의 일부일 필요는 없다.
- 응용 프로그램(application program)
  - 시스템 작동과 관련없는 모든 프로그램을 포함한다.

## 1.2 컴퓨터 시스템의 구성 (Computer-System Organization)

보통의 컴퓨터 시스템은 다음과 같이 구성된다:

- 하나 이상의 CPU
- 버스(bus)
  - 구성 요소와 공유 메모리 사이를 연결하여 액세스를 제공
- 여러 장치 컨트롤러(device controller)
  - 디스트 드라이브, 오디오 장치, 그래픽 디스플레이 등등

### 1.2.1 인터럽트 (Interrupt)

하드웨어는 어느 순간이든 시스템 버스(system bus)를 통해 CPU에 신호를 보내 인터럽트(interrupt)를 발생시킬 수 있다.

기본 인터럽트 메커니즘

1.  장치 컨트롤러가 인터럽트 요청 라인(interrupt request line)에 신호를 보내 인터럽트를 발생(raise)
2.  CPU가 인터럽트를 포착(catch)
3.  인터럽트 번호를 읽고 이 번호를 인터럽트 벡터(interrupt vector)의 인덱스로 사용하여 인터럽트 핸들러 루틴(interrupt-handler routine)으로 점프
4.  인터럽트 핸들러로 디스패치(dispatch)
    - 작업 중에 변경될 상태 저장
    - 인터럽트 원인 확인
    - 필요한 처리 수행
    - 상태 복원 수행
    - return_from_interrupt 명령어 실행하여 CPU를 인터럽트 전 실행 상태로 되돌림
5.  장치를 서비스하여 인터럽트 지움(clear)

### 1.2.2 저장장치 구조 (Storage Structure)

**부트스트랩 프로그램(bootstrap program)** 은 컴퓨터 전원을 켤 때 가장 먼저 실행되어 운영체제를 적재(load)하는 프로그램이다.

> bootstrap은 부츠같은 발목이 높은 신발을 신을 때 잡고 신을 수 있게 위쪽에 달려있는 끈을 의미한다.

**폰 노이만 구조(von Neumann architecture)** 시스템 에서 실행되는 전형적인 명령(instruction) 실행 사이클

1.  메모리로부터 **명령을 인출(fetch)**
2.  그 명령을 명령 레지스터(instruction register)에 저장(store)
3.  명령을 해독(decode)
    - 메모리로부터 피연산자(operands)를 인출하여 내부 레지스터(internal register)에 저장하도록 유발할 수 있음
4.  피연산자에 대해 **명령을 실행(execute)** 한 후에 결과가 메모리에 다시 저장될 수 있다.

대부분의 컴퓨터 시스템은 메인 메모리가 휘발성 저장장치에 용량이 너무 작은 부분을 보완하기 위해 메인 메모리의 확장으로 **보조저장장치(secondary storage)** 를 제공한다. 가장 일반적인 보조저장장치는 아래와 같다:

- 하드 디스크 드라이브(HDD)
- 비휘발성 메모리(NVM - nonvolatile memory) 장치

다른 장치에 저장된 자료의 백업 사본을 저장하기 위해 특수 목적으로만 사용하기 때문에 매우 느리고 충분히 큰 장치를 **3차 저장장치(tertiary storage)** 라고 한다.

![image](https://user-images.githubusercontent.com/59808674/163139106-9b60db90-308c-45bc-928a-fbb552dde2d1.png)

다양한 저장장치 시스템 간의 주요 차이점은 속도(access time), 크기(storage capacity), 그리고 휘발성(volatility)에 있다

### 1.2.3 입출력 구조 (I/O Structure)

인터럽트 구동(interrupt-driven) I/O의 형태는 소량의 데이터를 이동할 때는 좋지만 NVS(nonvolatile storage) I/O와 같은 대량 데이터 이동에 사용될 때 높은 오버헤드를 유발할 수 있다. 이 문제를 해결하기 위해 CPU의 개입없이 메모리로부터 자신의 버퍼장치로, 또는 반대로 데이터 블록 전체를 전송하는 **직접 메모리 액세스(DMA - direct memory access)** 가 사용된다.

- 바이트 단위가 아닌 블록 단위로 인터럽트가 발생
- 장치 컨트롤러가 전송작업을 하는 동안 CPU는 다른 작업 수행 가능

## 1.3 컴퓨터 시스템 구조 (Computer System Architecture)

컴퓨터 시스템은 사용된 범용 처리기(processor)의 수에 따라 분류 가능하다.

### 1.3.1 단일 처리기 시스템 (Single-Processor Systems)

과거, 대부분의 컴퓨터 시스템은 단일 처리 코어(core)를 가진 하나의 CPU를 포함하는 단일 프로세서를 사용했다.

- **코어(core)** 는 명령을 실행하고 로컬로 데이터를 저장하기 위한 레지스터를 포함하는 구성요소

### 1.3.2 다중 처리기 시스템 (Multiprocessor Systems)

일반적으로 멀티프로세서 시스템에는 각각 단일 코어 CPU가 있는 두 개 이상의 프로세서가 있다. 주요 장점은 처리량 증가이다. 즉 프로세서 수를 늘리면 더 적은 시간에 더 많은 작업을 수행할 수 있다. 하지만 N개의 프로세서를 사용한다고 N배만큼 빨라지는 것은 아니다.

가장 일반적인 멀티프로세서 시스템은 **SMP(symmetric multiprocessing)** 을 사용한다.

![image](https://user-images.githubusercontent.com/59808674/163140627-29a39b59-2bb7-4d05-a9e6-55fdd4351f79.png)

- SMP: 각 피어 CPU 프로세서가 운영체제 기능과 사용자 프로세스를 포함한 모든 작업을 수행
- 많은 프로세스를 동시에 실행할 수 있다는 장점을 가짐
- CPU가 독립적이기 때문에 하나는 유휴 상태(idle)이고 다른 하나는 과부하(overloaded)가 걸려 비효율적일 수 있음
  - 프로세서가 특정 자료구조를 공유하면 비효율성을 피할 수 있음

멀티프로세서의 정의는 시간이 지남에 따라 발전해 왔으며 이제는 **다중 코어(multicore)** 시스템을 포함한다.

- 멀티코어: 여러 개의 컴퓨팅 코어가 단일 칩에 상주하는 것을 의미
  - 칩 내 통신이 칩 간 통신보다 빠르므로 멀티코어 시스템은 싱글코어를 가지는 여러 칩보다 효율적일 수 있다.
  - 여러 개의 단일코어 칩보다 하나의 멀티코어 칩이 훨씬 적은 전력을 사용한다.

## 1.4 운영체제의 작동 (Operating-System Operations)

또 다른 형태의 인터럽트는 **트랩(trap)** 또는 **예외(exception)** 로, 오류(0 으로 나누거나 유효하지 않은 메모리 액세스)나 사용자 프로그램의 특정 요청으로 발생하는 **소프트웨어 생성 인터럽트**이다. 이러한 특정 요청은 **시스템 콜(system call)** 이라는 특수 연산을 실행하여 요청되고 운영체제가 제공하는 서비스가 수행될 것을 요구한다.

### 1.4.1 다중 프로그래밍과 다중 태스킹 (multiprogramming and multitasking)

**다중 프로그래밍(multiprogramming)** 은 한 번에 둘 이상의 프로그램을 실행하는 것을 의미한다.

- CPU가 항상 한 개는 실행하도록 프로그램을 구성하여 CPU 이용률(utilization)을 높인다.
- 멀티프로그래밍 시스템에서 실행 중인 프로그램을 프로세스(process)라고 한다.

1.  운영체제는 여러 프로세스를 동시에 메모리에 유지
2.  이러한 프로세스 중 하나를 선택해 실행
3.  멀티프로그래밍 시스템이 아닐 경우에는 I/O 작업과 같은 일부 작업이 완료 될 때까지 CPU가 유휴(idle)상태로 기다릴 수 있지만, 멀티프로그래밍 시스템에서 운영체제는 단순히 다른 프로세스로 전환하여 실행
4.  해당 프로세스가 또 대기해야 할 경우, CPU는 또 다른 프로세스로 전환
5.  결과적으로 첫 번째 프로세스가 대기를 마치고 CPU를 다시 돌려받는다.

- 위의 과정을 통해 멀티프로그래밍 시스템에서는 CPU가 하나 이상의 프로세스를 실행해야하는 한 유휴상태로 남아 있지 않는다는 것을 알 수 있다.

**다중 태스킹(multitasking)** 은 멀티프로그래밍의 논리적 확장이다.

- 멀티태스킹 시스템에서는 CPU가 여러 프로세스를 전환하며 프로세스를 실행하지만 전환이 자주 발생하여 사용자에게 빠른 응답시간(response time)을 제공하게 된다.
  - 사용자가 타이핑 속도가 빠르던, 느리던, 그것에 구애받지 않고 I/O작업이 수행될 때는 다른 프로그램으로 전환하여 CPU를 쉬지 않게 함
- 동시에 여러 프로세스를 메모리에 유지하기 위한 메모리 관리 방식이 필요하며, 여러 프로세스가 동시에 실행될 준비가 되면 시스템은 다음에 실행할 프로세스를 선택해야 하는데, 이러한 결정을 내리는 것을 **CPU 스케줄링(CPU scheduling)** 이라고 한다.
- 멀티태스킹 시스템에서는 운영체제가 적절한 응답시간을 보장해야하는데 이를 위한 일반적인 방법은 **가상 메모리(virtual memory)** 다.
  - 일부만 메모리에 적재된 프로세스의 실행을 허용하는 기법
  - 프로그램이 물리 메모리(physical memory)의 크기보다 더 커도 된다.
  - 메인 메모리를 크고 균등한 저장장치의 배열로 추상화하여, 사용자에게 보이는 논리 메모리(logical memory)를 물리 메모리로부터 분리시킨다.
    - 프로그래머를 메모리 저장장치의 한계로부터 자유롭게 해줌

### 1.4.2 이중모드와 다중모드 운용 (Dual-Mode and Multimode Operation)

시스템을 올바르게 실행하기 위해 운영체제 코드 실행과 사용자 정의 코드 실행을 구분할 수 있어야 한다. 그를 위해 적어도 두 개의 독립된 연산 모드, 즉 **사용자 모드(user mode)** 와 **커널 모드(kernel mode)** 를 필요로 한다.

![image](https://user-images.githubusercontent.com/59808674/163140832-5c765c96-8681-42ef-8cee-c7d628ef0d4a.png)

- 커널 모드는 수퍼바이저 모드(supervisor mode), 시스템 모드(system mode), 혹은 특권 모드(privileged mode) 로도 부른다.
- 모드 비트(mode bit)로 현재 모드를 나타낸다
  - 커널 모드(0), 사용자 모드(1)
- 사용자 모드에서 시스템 콜을 호출하면 커널 모드로 전환(모드 비트 0으로 변경)하여 시스템 콜을 실행하고 다시 사용자 모드로 복귀(모드 비트 1로 설정)한다.

## 1.7 가상화 (Virtualization)

가상화(virtualization)는 단일 컴퓨터의 하드웨어를 여러 가지 실행 환경으로 추상화하는 기술이다.

- 그렇게 추상화된 개별 환경이 자신만의 컴퓨터에서 실행되고 있다는 환상을 만들어준다.

가상머신(virtual machine)의 사용자는 단일운영체제에서 동시에 실행되는 프로세스들을 전환하는 방식과 동일한 방식으로 운영체제간의 전환을 할 수 있다.

![image](https://user-images.githubusercontent.com/59808674/163141258-be8d5c56-b449-4c7e-8517-acf230b4acf9.png)

가상머신 관리자(VMM - virtual machine manager)는 게스트(guest) 운영체제를 수행하고 그들의 자원이용을 관리하며 각 게스트를 서로로부터 보호한다.

- VMware, XEN, WSL 등등
- 가상화가 하나의 호스트(host) 운영체제에서 다른 게스트(guest)운영체제를 사용가능하게 해주는 기술이라면, VMM은 가상 머신 프로세스에게 서비스 및 자원관리를 제공하는 호스트 운영체제 그 자체이다.

## 1.10 계산 환경 (Computing Environments)

### 1.10.2 모바일 컴퓨팅 (Mobile Computing)

휴대용 스마트폰과 태블릿 컴퓨터의 컴퓨팅 환경을 말한다

- 이동 가능하고 가볍다는 물리적인 특징
- 두 가지의 지배적인 운영체제
  - Apple iOS
  - Google Android

### 1.10.3 클라이언트 서버 컴퓨팅 (Client-Server Computing)

서버 시스템이 클라이언트 시스템이 생성한 요청(request)을 제공(response)하는 배치가 특징이다.

- 대표적인 예로 Web

### 1.10.4 피어 간 계산 (Peer-to-Peer Computing)

클라이언트와 서버가 서로 구별되지 않고, 시스템 상의 모든 노드가 피어(peer)로 간주되어 각 피어가 서비스를 요청(request)하느냐 제공(response)하느냐에 따라 클라이언트 및 서버로 동작한다.

### 1.10.5 클라우드 컴퓨팅 (Cloud Computing)

계산, 저장장치는 물론 응용조차도 네트워크를 통한 서비스로 제공하는 계산 유형이다.

- 어떤 면에서는 가상화를 클라우드 컴퓨팅의 기반으로 사용하기 때문에 가상화의 논리적 확장이라 볼 수 있다.
- 공공(public) 클라우드: 서비스를 위해 지불 가능한 사람은 누구나 인터넷을 통해 사용 가능한 클라우드
  - AWS, Azure
- 사유(private) 클라우드: 한 회사가 사용하기 위해 운영하는 클라우드
- 혼합형(hybrid) 클라우드: 공공과 사유 부분을 모두 포함하는 클라우드
- 소프트웨어 서비스(software as a service, SaaS): 인터넷을 통해 사용 가능한 하나 이상의 응용(application)
  - 워드 프로세서, 스프레드 시트
- 플랫폼 서비스(platform as a service, PaaS): 인터넷을 통해 사용하도록 앱 사용에 맞게 준비된 소프트웨어 스택
  - 데이터베이스 서버
- 하부구조 서비스(infrastructure as a service, IaaS): 인터넷을 통해 사용 가능한 서버나 저장장치
  - 생산 데이터의 백업 복사본을 만들기 위한 저장장치
  - Amazon의 AWS, Microsoft의 Azure
